## 合约测试
### console.log
可以打印日志

### forge test -vvvvv

v 越多，显⽰的测试报告越详细
• -vv: 增加显⽰测试过程中的⽇志
• -vvv：增加显⽰失败测试的堆栈跟踪
• -vvvv: 显⽰所有测试的堆栈跟踪，并显⽰失败测试的setup跟踪
• -vvvvv: 始终显⽰堆栈跟踪和设置跟踪


### Gas 报告
forge test —gas-report
forge test test/Counter.t.sol --fuzz-runs 2000 -vv --gas-report

为Gas消耗生成一个快照文件(默认为 .gas-snapshot)：
```
forge snapshot
forge snapshot --snap <FILE_NAME>
```

代码修改后，不同的 .gas-snapshot 对比 gas 消耗：

```
forge snapshot --diff .gas-snap2 // 当前运行的snap 与 gas-snap2 对比
forge snapshot --check .gas-snap2 // 对比并显示不同
```

### 合约测试 作弊码
Foundry 在 vm 合约中提供了一组作弊码，已在 Test 合约中定义 vm 成员供使用，⽤于在测试中模拟各种场景和条件，作弊码分以下几
类：
• Environment（环境）：改变 EVM 状态的作弊码。
• Assertions（断言）：断言作弊码。
• Fuzzer（模糊测试器）：配置模糊测试器的作弊码。
• External（外部）：与外部状态（文件、命令等）交互的作弊码。
• Utilities（实用工具）：实用工具作弊码。
• Forking（分叉）：分叉模式的作弊码。
• Snapshots（快照）：快照作弊码。
• RPC：与 RPC 相关的作弊码。
• File（文件）：处理文件的作弊码。

### 常用作弊码
• vm.roll(uint256 blockNumber)：模拟区块号的变更。
• vm.warp(uint256 timestamp)：改变区块时间戳。 skip(1000); // 前进时间
• vm.prank(address sender)：更改下一个调用的发送者（msg.sender）。  vm.startPrank()
• vm.deal(address to, uint256 amount)：重置ETH余额到指定地址。
• deal(address token, address to, uint256 amount)：重置ERC20代币余额。


### 断⾔合约执⾏错误
vm.expectRevert() / expectRevert(bytes4 revertData) / expectRevert(bytes calldata revertData)

```
function transferOwnership(address newOwner) public {
require(msg.sender == owner, "Only the owner can transfer ownership");
owner = newOwner;
}
```

```
function test_Revert_IFNOT_Owner() public {
    vm.startPrank(alice);
    Owner o = new Owner();
    vm.stopPrank();
    vm.startPrank(bob);
    vm.expectRevert("Only the owner can transfer ownership"); // 预期下一条语句会revert
    o.transferOwnership(alice);
    vm.stopPrank();
}

// forge test test/Cheatcode.t.sol --mt test_Revert_IFNOT_Owner -vv
```

### 断⾔合约执⾏错误
```
error NotOwner(address caller);
function transferOwnership2(address newOwner) public {
if (msg.sender != owner) revert NotOwner(msg.sender);
owner = newOwner;
}
```

```
function test_Revert_IFNOT_Owner2() public {
    vm.startPrank(alice);
    Owner o = new Owner();
    vm.stopPrank();
    vm.startPrank(bob);
    bytes memory data = abi.encodeWithSignature("NotOwner(address)", bob);
    vm.expectRevert(data); // 预期下一条语句会revert
    o.transferOwnership2(alice);
    vm.stopPrank();
}
// forge test test/Cheatcode.t.sol --mt test_Revert_IFNOT_Owner2 -vv
```

## 断⾔合约事件
测试合约执⾏是否有出现符合预期的合约Event记录
```
event OwnerTransfer(address indexed caller, address indexed newOwner);
function transferOwnership(address newOwner) public {
require(msg.sender == owner, "Only the owner can transfer ownership");
owner = newOwner;
emit OwnerTransfer(msg.sender, newOwner);
}
```

```
function test_Emit() public {
    Owner o = new Owner();
    vm.expectEmit(true, true, false, false);
    emit OwnerTransfer(address(this), bob);
    o.transferOwnership(bob);
}
// forge test test/Cheatcode.t.sol --mt test_Emit -vv

```

## Fork（分叉）测试
例如当需要与线上现有合约进行交互时，分叉测试特别有用。
• 每个分叉是一个独立的 EVM，在分叉的快照之上有独立的存储
• 两个方法: 分叉模式和分叉作弊码

分叉模式
```
forge test --fork-url <your_rpc_url> --fork-block-number 1
forge test test/Counter.t.sol --fork-url <your_rpc_url> -vv
```

### Fork（分叉）测试
分叉作弊码
```
function setUp() public {
    uint forkBlock = 8219000;
    sepoliaForkId = vm.createSelectFork(vm.rpcUrl("sepolia"), forkBlock);
}


function test_Something() public {
    vm.selectFork(sepoliaForkId);
    assertEq(vm.activeFork(), sepoliaForkId);
    MyERC20 token = MyERC20(0x21b4D1f6d42dc6083db848D42AA4b6895371E1e7);
    assertGe(token.balanceOf(0xe74c813e3f545122e88A72FB1dF94052F93B808f), 1e18);
}
// forge test test/Fork.t.sol --mt test_Something -vv
```

## 模糊（Fuzz）测试
通过随机输⼊数据来测试合约的健壮性
随机输⼊ x 测试 .setNumber(x) 的健壮性
```
function testFuzz_SetNumber(uint256 x) public {
    counter.setNumber(x);
    assertEq(counter.number(), x);
}
```
结果中的含义
μ 所有模糊运行中使用的平均 Gas
~ 所有模糊运行中使用的中值 Gas

通过随机输⼊数据来测试合约的健壮性

随机输⼊ to 和 about 测试 转账的健壮性
assume 设置条件， bound 设置取值范围

```
function testFuzz_ERC20Transfer(address to, uint256 amount) public {
    vm.assume(to != address(0));
    vm.assume(to != address(this));
    amount = bound(amount, 0, 10000 * 10 ** 18);
    // vm.assume(amount <= token.balanceOf(address(this)));
    token.transfer(to, amount);
    assertEq(token.balanceOf(to), amount);
}
```


## 不变量（invariant）测试
在随机的调用序列和模糊输入下，每个函数执行候，所定义的变量保持不变。
• 如所有⽤户 ERC20 余额的总和等于总供应量， AMM 总是 K = x*y
• 在函数名称前加上 invariant 来表示不变量测试
• 使用 targetContract 和 targetSelector 来指定要测试的合约和函数








