## 签名应用
### 1、交易构造与签名
1. ABI 编码

2. 构造交易

3. RLP 序列化、 Hash、签名

4. 广播上链

5. 签名在节点验证



### 2、签名应用 - SIWE
• 用户通过签署一段规范的消息来证明对地址的控制权。

• 签名在后端验证，实现去中心化的登录认证。



## 如何在合约中验证签名？
### 签名你需要知道
• 签名一个事务 -> 代表自己授权做某事务

• 签名特性：身份认证、不可否认、完整性

• 签名是线下行为、无需 Gas 费

• 对交易签名和对其他任意信息签名没有本质区别，只是数据（编码格式）不一样

• 盲目签名将造成资金损失

### 签名标准
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770208187934-e1277b49-6b78-41e2-a69d-41f0a3d2ab41.png)

• 编码格式：EIP191 / EIP712

• Keccak256 哈希算法，是 SHA-3 族：安全性⾼，灵活，速度快

• 椭圆曲线加密算法 Secp256k1：⾼效性，安全性，标准化





规范编码格式

• EIP191： 区分交易签名和其他信息签名

• EIP712： 定义结构化信息签名标准

#### EIP191
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770208385328-6f4bf133-32a3-4733-bef8-2e413456173f.png)

• EIP191： 区分**交易签名和其他信息签名**

• 0x19 初始字节： 这个初始字节确保 signed_data 不是有效的 RLP 编码，从⽽防⽌签名数据被误解为以太坊交易。

• <1 byte version>：可以⾃⾏定义签名数据版本，占⽤⼀字节，可以是0；

• <version sepific data>： 不定长的消息头数据；

• <data to sign>：原始签名数据;

##### 签名和验证签名
```tsx
import { createWalletClient, http, createPublicClient, verifyMessage, hashMessage } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

async function main() {
  const privateKey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
  const account = privateKeyToAccount(privateKey)

  console.log('钱包地址:', account.address)

  // 创建钱包客户端
  const walletClient = createWalletClient({
    account,
    chain: mainnet,
    transport: http()
  })

  // 要签名的消息
  const message = 'hello world'

  const hash = await hashMessage(message)
  console.log('hash:', hash)


  // 签名消息
  const signature = await walletClient.signMessage({
    message
  })
  console.log('签名结果:', signature)

  // 验证签名
  const isValid = await verifyMessage({
    address: account.address,
    message,
    signature
  })

  // Solidity 合约验证：
  // function recover(bytes memory message, bytes memory signature) public pure returns (address) {
  //     bytes32 hash = MessageHashUtils.toEthSignedMessageHash(message);

  //     return ECDSA.recover(hash, signature);
  // }

  console.log('签名验证结果:', isValid ? '验证成功' : '验证失败')
}

main().catch((error) => {
  console.error('发生错误:', error)
  process.exit(1)
}) 
```



合约验签 TestVerify

```solidity
import { ECDSA } from "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/
contracts/utils/cryptography/ECDSA.sol";
import { MessageHashUtils } from "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/
master/contracts/utils/cryptography/MessageHashUtils.sol";

contract TestVerify {
  // message: hello world -> 0x68656c6c6f20776f726c64 （ascii-to-hex）
  // Signature
  function recover(bytes memory message, bytes memory signature) public pure returns
  (address) {
    bytes32 hash = MessageHashUtils.toEthSignedMessageHash(message);
    return ECDSA.recover(hash, signature);
  }
}

```



#### EIP-712
定义结构化数据签名

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770208430782-1c9fea7b-7e2e-46d4-9a23-63afc48303bc.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770208889879-774cc172-b5db-4c16-be3c-fa585f6e672f.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770208969229-9cefe094-8db0-4add-a94f-5de7a0af0152.png)



## EIP签名转账案例
### 前端签名
```tsx
'use client';

import { useState, useEffect } from 'react';
import { 
  createWalletClient, 
  createPublicClient, 
  http, 
  parseEther,
  type Hash,
  type Address,
  custom,
  type WalletClient
} from 'viem';
import { foundry } from 'viem/chains';
import { EIP712VerifierABI } from '@/types/EIP712Verifier';

const CONTRACT_ADDRESS = '0x5FbDB2315678afecb367f032d93F642f64180aa3' as Address;

export default function EIP712Demo() {
  const [toAddress, setToAddress] = useState('');
  const [amount, setAmount] = useState('');
  const [signature, setSignature] = useState('');
  const [verificationResult, setVerificationResult] = useState<boolean | null>(null);
  const [account, setAccount] = useState<Address | null>(null);
  const [error, setError] = useState<string>('');
  const [walletClient, setWalletClient] = useState<WalletClient | null>(null);

  // 创建公共客户端
  const publicClient = createPublicClient({
    chain: foundry,
    transport: http()
  });

  // 在客户端初始化钱包客户端
  useEffect(() => {
    if (typeof window !== 'undefined' && window.ethereum) {
      const client = createWalletClient({
        chain: foundry,
        transport: custom(window.ethereum)
      });
      setWalletClient(client);
    }
  }, []);

  // 连接钱包
  const connectWallet = async () => {
    if (!walletClient) {
      setError('钱包客户端未初始化，请确保已安装 MetaMask');
      return;
    }

    try {
      setError('');
      // 请求用户授权连接钱包
      const [address] = await walletClient.requestAddresses();
      setAccount(address);
    } catch (error) {
      console.error('连接钱包错误:', error);
      setError('连接钱包失败，请确保已安装 MetaMask 并解锁');
    }
  };

  const handleSign = async () => {
    if (!walletClient || !account) {
      setError('请先连接钱包');
      return;
    }

    if (!toAddress || !amount) {
      setError('请填写接收地址和金额');
      return;
    }

    try {
      setError('');
      const domain = {
        name: 'EIP712Verifier',
        version: '1.0.0',
        chainId: 31337,
        verifyingContract: CONTRACT_ADDRESS,
      };

    // 合约中的 SEND_TYPEHASH 与前端定义的 types 结构一致
      const types = {
        Send: [  //  primaryType, 签名时, 消息的标题会显示 primaryType 的名称
          { name: 'to', type: 'address' },
          { name: 'value', type: 'uint256' },
        ],
      };

      const msg = {
        to: toAddress as Address,
        value: parseEther(amount),
      };

      // 请求用户签名
      const signature = await walletClient.signTypedData({
        account,
        domain,
        types,
        primaryType: 'Send',
        message: msg,
      });

      setSignature(signature);
    } catch (error) {
      console.error('签名错误:', error);
      setError(error instanceof Error ? error.message : '签名失败');
    }
  };

  const handleVerify = async () => {
    if (!account || !signature) {
      setError('请先完成签名');
      return;
    }

    try {
      setError('');
      const result = await publicClient.readContract({
        address: CONTRACT_ADDRESS,
        abi: EIP712VerifierABI,
        functionName: 'verify',
        args: [
          account,
          {
            to: toAddress as Address,
            value: parseEther(amount),
          },
          signature as Hash,
        ],
      });

      setVerificationResult(result);
    } catch (error) {
      console.error('验证错误:', error);
      setError(error instanceof Error ? error.message : '验证失败');
    }
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">EIP712 Viem 签名演示</h1>
      
      {!account ? (
        <button
          onClick={connectWallet}
          className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mb-4"
        >
          连接钱包
        </button>
      ) : (
        <div className="space-y-4">
          <div>
            <label className="block mb-2">接收地址:</label>
            <input
              type="text"
              value={toAddress}
              onChange={(e) => setToAddress(e.target.value)}
              className="w-full p-2 border rounded"
              placeholder="0x..."
            />
          </div>

          <div>
            <label className="block mb-2">金额 (ETH):</label>
            <input
              type="number"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              className="w-full p-2 border rounded"
              placeholder="0.1"
            />
          </div>

          <div className="space-x-4">
            <button
              onClick={handleSign}
              className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
            >
              签名
            </button>
            
            <button
              onClick={handleVerify}
              className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
              disabled={!signature}
            >
              验证
            </button>
          </div>

          {error && (
            <div className="mt-4 text-red-500">
              {error}
            </div>
          )}

          {signature && (
            <div className="mt-4">
              <h2 className="font-bold">签名结果:</h2>
              <p className="break-all">{signature}</p>
            </div>
          )}

          {verificationResult !== null && (
            <div className="mt-4">
              <h2 className="font-bold">验证结果:</h2>
              <p className={verificationResult ? 'text-green-500' : 'text-red-500'}>
                {verificationResult ? '验证成功' : '验证失败'}
              </p>
            </div>
          )}
        </div>
      )}
    </div>
  );
} 
```



### 合约验证签名
```tsx
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

contract EIP712Verifier is EIP712 {
    using ECDSA for bytes32;

    struct Send {
        address to;
        uint256 value;
    }

    bytes32 public constant SEND_TYPEHASH = keccak256("Send(address to,uint256 value)");

    constructor() EIP712("EIP712Verifier", "1.0.0") {}

    function hashSend(Send memory send) public view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    SEND_TYPEHASH,
                    send.to,
                    send.value
                )
            )
        );
    }

    function verify(
        address signer,
        Send memory send,
        bytes memory signature
    ) public view returns (bool) {
        bytes32 digest = hashSend(send);
        return digest.recover(signature) == signer;
    }

    function sendByEIP712Signature(address signer, address to, uint256 value, bytes memory signature ) public {
        require(verify(signer, Send({to: to, value: value}), signature), "Invalid signature");
        (bool success, ) = to.call{value: value}("");
        require(success, "Transfer failed");
    }


} 
```



## ERC20-授权问题
授权、转账需要两笔交易

• 如果要优化体验，无线授权给 Bank ， 可能带来安全问题

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770216986284-d2b5cfbf-69c3-4648-956d-c38bfe8729a5.png)

### ERC20-Permit（EIP2612）
签名授权

• （授权）可以在线下签名进行，签名信息可以在执行接收转账交易时提交到链上（permit），让授权和转账在一笔交易里完成。

• 同时转账交易也可以由接收方（或其他第三方）来提交，也避免了用户（ERC20的拥有者）需要有 ETH的依赖。

```solidity
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ERC2612 is ERC20Permit {
  constructor() ERC20("ERC2612", "ERC2612") ERC20Permit("ERC2612") {
    _mint(msg.sender, 1000 * 10 ** 18);
  }


    bytes32 private constant PERMIT_TYPEHASH =
        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
  
  function permit(address owner, address spender, uint256 value, uint256 deadline,
                  uint8 v, bytes32 r, bytes32 s) public virtual {
    
      if (block.timestamp > deadline) {
        revert ERC2612ExpiredSignature(deadline);
      }
    
      bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, 
                                                value, _useNonce(owner), deadline));
    
      bytes32 hash = _hashTypedDataV4(structHash);
      address signer = ECDSA.recover(hash, v, r, s);
      if (signer != owner) {
        revert ERC2612InvalidSigner(signer, owner);
      }
    
      _approve(owner, spender, value);
  }
}
```



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770217226627-d6dba587-5b62-4a3f-906b-f3256fb7788a.png)





### Token 存款方式
21000 GAS + approve 功能

21000 GAS + deposit功能

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770217331144-f6cae996-4738-44dd-94d8-072288ba481a.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770217347533-fb36579b-29b4-4640-ba79-51bd6af74b34.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770217351690-47dd53ac-313c-4bb0-8349-a94a666a5f67.png)

21000 GAS + deposit （approve）





## ERC721-PERMIT
EIP-4494 ： 离线授权一个 tokenID

• 同时解决了一个 ERC721 小问题：不能给 tokenID 授权给多个地址。

• 允许用户为同一 TokenID 创建多个 spender 地址的许可签名， 直到 TokenID 转移失效。

```solidity
bytes32 hashStruct = keccak256( abi.encode(
        keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)"),
        spender,
        tokenId,
        nonces[tokenId], // 当 NFT 实际转移时，nonce 才会递增
        deadline)
);
function _transfer(address from, address to, uint256 tokenId) internal override {
    _nonces[tokenId]++;
    super._transfer(from, to, tokenId);
}
```

参考实现 [https://github.com/soliditylabs/ERC721-Permit](https://github.com/soliditylabs/ERC721-Permit) 及 Uniswap ERC721-Permit



## Permit2
• 有没有办法让为所有的 Token 合约实现离线授权？

• Uniswap Permit2 结合了 approve 与 erc2612 - permit

[https://github.com/Uniswap/permit2](https://github.com/Uniswap/permit2)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770217600591-ca17ff33-ac39-447c-ba0f-060d53916338.png)



### 交互流程：
• Alice在一个ERC20上调用 approve ，无限的授权给 Permit2 合约 （在各个链上有相同的地址）

• Alice签署链下消息：表明协议合约被允许代表她转账代币

• 协议合约上调用一个交互函数，将签署的 permit2 消息作为参数传入

• Permit2合约上调用 permitTransferFrom， Permit2 按照消息指示转移 Token 到协议

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770217629048-527e192c-6d3b-4bdd-bc8f-daf04622ec58.png)

任意的协议可共享用户对 Permit2 的授权





## 使用签名要注意
• 签名被重用

• 如何防止重用，签名中加入

• Nonce

• Deadline (可选，但推荐)

• 业务逻辑 + 授权（amount：， spender）



## 作业
### 作业1
• 使用 EIP2612 标准（可基于 Openzepplin 库）编写一个自己名称的 Token 合约。

• 修改 TokenBank 存款合约 ,添加一个函数 permitDeposit 以支持离线签名授权（permit）

进行存款，在前端签名授权存款

• 修改Token 购买 NFT NTFMarket 合约，添加功能 permitBuy() 实现只有离线授权的白名

单地址才可以购买 NFT （用自己的名称发行 NFT，再上架） 。白名单具体实现逻辑

为：项目方给白名单地址签名，白名单用户拿到签名信息后，传给 permitBuy() 函数，

在permitBuy()中判断时候是经过许可的白名单用户，如果是，才可以进行后续购买，否

则 revert 。

[https://decert.me/challenge/fc66ef6c-35db-4ee7-b11d-c3b2d3fa356a](https://decert.me/challenge/fc66ef6c-35db-4ee7-b11d-c3b2d3fa356a)





### 作业2
• 原来的 TokenBank 添加一个方法 depositWithPermit2()， 这个方式

使用 permit2 进行签名授权转账来进行存款

• 方法修改 Token 存款前端 让用户可以在前端通过 permit2 的签名

存款。

[https://decert.me/quests/1fa3ecbc-a3cd-43ae-908e-661aac97bdc0](https://decert.me/quests/1fa3ecbc-a3cd-43ae-908e-661aac97bdc0)









