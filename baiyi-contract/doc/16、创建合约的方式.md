• 使用 Remix/Foundry 创建的合约地址是如何生成的？

• 如何合约部署到一个确定的地址上

• 大规模部署相同功能的合约如何节省 Gas



### <font style="color:rgb(31, 31, 31);">1. 合约创建基础 (CREATE)</font>
+ **<font style="color:rgb(31, 31, 31);">创建方式</font>**<font style="color:rgb(31, 31, 31);">：可以通过外部工具（如 Remix, Hardhat, Foundry）或在合约内使用 </font>`<font style="color:rgb(68, 71, 70);">new</font>`<font style="color:rgb(31, 31, 31);"> 关键字进行部署 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">操作码</font>**<font style="color:rgb(31, 31, 31);">：在 EVM 中，这些操作通常通过 </font>`<font style="color:rgb(68, 71, 70);">CREATE</font>`<font style="color:rgb(31, 31, 31);"> 操作码实现 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">地址计算</font>**<font style="color:rgb(31, 31, 31);">：地址是由创建者（sender）的地址及创建者发送过的交易数量（nonce）确定的 。</font>
    - **<font style="color:rgb(31, 31, 31);">计算公式</font>**<font style="color:rgb(31, 31, 31);">：</font>`<font style="color:rgb(68, 71, 70);">keccak256(rlp.encode([normalize_address(sender), nonce])) [12:]</font>`<font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">缺点</font>**<font style="color:rgb(31, 31, 31);">：地址难以控制，在多链环境下保持地址一致比较麻烦， 适合于不需要预测的情况</font>

```javascript
function createContract1() public returns (address) {
  C c = new C();
  return address(c);
}
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770303590669-0f888847-a837-4b3f-9270-a4f95c1cf360.png)



合约工厂: 每创建一个合约 nonce += 1





### <font style="color:rgb(31, 31, 31);">2. 确定性部署 (CREATE2)</font>
+ **<font style="color:rgb(31, 31, 31);">特点</font>**<font style="color:rgb(31, 31, 31);">：使用 </font>`<font style="color:rgb(68, 71, 70);">salt</font>`<font style="color:rgb(31, 31, 31);">（盐）来控制合约地址，实现确定性的创建 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">地址计算</font>**<font style="color:rgb(31, 31, 31);">：由创建者地址、用户设置的 </font>`<font style="color:rgb(68, 71, 70);">salt</font>`<font style="color:rgb(31, 31, 31);"> 以及合约的初始化字节码（init_code）共同决定 </font><font style="color:rgb(31, 31, 31);">。</font>
    - **<font style="color:rgb(31, 31, 31);">计算公式</font>**<font style="color:rgb(31, 31, 31);">：</font>`<font style="color:rgb(68, 71, 70);">keccak256(0xff ++ sender ++ salt ++ keccak256(init_code))[12:]</font>`<font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">应用场景</font>**<font style="color:rgb(31, 31, 31);">：适用于需要提前确定合约地址的场景，如流动性池、合约钱包以及实现多链地址一致性 </font><font style="color:rgb(31, 31, 31);">。</font>

```javascript
function create2Contract(uint _salt) public returns (address) {
  C c = new C{salt: keccak256(abi.encode(_salt))}();
  return address(c);
}
```



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770303775773-fcfea6b1-4293-4fba-96da-995d9d26ef4c.png)

#### 优点
• 用一样的 salt 再次创建会如何？

• 提前确定地址有什么好处或使用场景

• 流动性池、合约钱包等

• 多链一致



### <font style="color:rgb(31, 31, 31);">3. 高级确定性部署 (CREATE3)</font>
+ **<font style="color:rgb(31, 31, 31);">特点</font>**<font style="color:rgb(31, 31, 31);">：创建的合约地址虽然是确定性的，但不与特定的合约字节码绑定 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">原理</font>**<font style="color:rgb(31, 31, 31);">：工厂合约先使用 </font>`<font style="color:rgb(68, 71, 70);">CREATE2</font>`<font style="color:rgb(31, 31, 31);"> 部署一个中间部署器，再由该部署器通过 </font>`<font style="color:rgb(68, 71, 70);">CREATE</font>`<font style="color:rgb(31, 31, 31);"> 方式部署最终的用户合约 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">优势</font>**<font style="color:rgb(31, 31, 31);">：相比 </font>`<font style="color:rgb(68, 71, 70);">CREATE2</font>`<font style="color:rgb(31, 31, 31);">，它更容易实现多链地址一致性，因为它不依赖于合约代码的哈希值 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">缺点</font>**<font style="color:rgb(31, 31, 31);">：相比之下 Gas 消耗较高 </font><font style="color:rgb(31, 31, 31);">。</font>

<font style="color:rgb(31, 31, 31);"></font>

<font style="color:rgb(31, 31, 31);">参考实现：</font>[https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770303939518-408bc71e-0192-4f22-aad6-5cdb4238592a.png)



```javascript
function create3Contract(uint _salt, bytes memory creationCode) external returns (address deployed) {
    deployed = CREATE3.deploy(
      keccak256(abi.encode(_salt)),
      creationCode,
      0
    );
}
```





### <font style="color:rgb(31, 31, 31);">4. 最小代理 (Minimal Proxy / EIP-1167)</font>
+ **<font style="color:rgb(31, 31, 31);">核心原理</font>**<font style="color:rgb(31, 31, 31);">：利用 </font>`<font style="color:rgb(68, 71, 70);">delegatecall</font>`<font style="color:rgb(31, 31, 31);">（委托调用）机制 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">结构</font>**<font style="color:rgb(31, 31, 31);">：代理合约仅保留最小的功能（即代理功能本身），所有的业务逻辑都委托给一个已存在的实现合约 </font><font style="color:rgb(31, 31, 31);">。</font>
+ **<font style="color:rgb(31, 31, 31);">优势</font>**<font style="color:rgb(31, 31, 31);">：当需要大规模部署功能完全相同的合约时，可以大幅节省部署所需的 Gas 成本 。</font>

<font style="color:rgb(31, 31, 31);"></font>

• 最小代理提案：[https://eips.ethereum.org/EIPS/eip-1167](https://eips.ethereum.org/EIPS/eip-1167)

• 实现：[https://github.com/optionality/clone-factory](https://github.com/optionality/clone-factory)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770304141886-05aa9428-22f2-45df-a7da-caad3d60f379.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770304146240-246758e1-c028-46b0-a4d2-bed6954224c7.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770304149896-d978680b-f1b5-4737-b57f-d31686ae8919.png)

```javascript
function createMinContract(address impl) public returns (address) {
    return createClone(impl);
}
```



### <font style="color:rgb(31, 31, 31);">5. 总结与对比 </font>
+ **<font style="color:rgb(31, 31, 31);">CREATE</font>**<font style="color:rgb(31, 31, 31);">：简单直接，但地址不可控。</font>
+ **<font style="color:rgb(31, 31, 31);">CREATE2</font>**<font style="color:rgb(31, 31, 31);">：地址可预测，但地址与代码逻辑绑定。</font>
+ **<font style="color:rgb(31, 31, 31);">CREATE3</font>**<font style="color:rgb(31, 31, 31);">：地址可预测且不依赖代码逻辑，但 Gas 较高。</font>
+ **<font style="color:rgb(31, 31, 31);">最小代理</font>**<font style="color:rgb(31, 31, 31);">：最适合大量重复部署以节约 Gas。</font>

<font style="color:rgb(31, 31, 31);"></font>

### <font style="color:rgb(31, 31, 31);">6. 实践练习 </font>
#### 练习题1
• 实现一个工厂合约，在以太坊上用 ERC20 模拟 meme 铸造（用最小代理）：

• 方法 1：deployInscription(string symbol, uint totalSupply, uint perMint)

• 方法 2：mintInscription(address tokenAddr)

[https://decert.me/quests/75782f22-edb8-4e82-9b68-0a4f46fcaadd](https://decert.me/quests/75782f22-edb8-4e82-9b68-0a4f46fcaadd)



#### 练习题2
• 在以太坊上用 ERC20 模拟铭文铸造，创建可升级的工厂合约：

• 方法1：deployInscription(string symbol, uint totalSupply, uint perMint)

• 方法 2：mintInscription(address tokenAddr)

• 第 2 个版本加入铸造费用（price）

[https://decert.me/quests/ac607bb0-53b5-421f-a9df-f3db4a1495f2](https://decert.me/quests/ac607bb0-53b5-421f-a9df-f3db4a1495f2)









