## <font style="color:rgb(31, 31, 31);">一、 合约升级的核心驱动力与迁移方案</font>
**<font style="color:rgb(31, 31, 31);">1. 为什么需要升级？</font>**

<font style="color:rgb(31, 31, 31);">区块链合约具有“部署即不可篡改”的特性。但在实际开发中，开发者面临三大痛点：</font>

+ **<font style="color:rgb(31, 31, 31);">修复漏洞：</font>**<font style="color:rgb(31, 31, 31);"> 代码上线后发现的安全风险需紧急封堵。</font>
+ **<font style="color:rgb(31, 31, 31);">功能迭代：</font>**<font style="color:rgb(31, 31, 31);"> 随着业务发展，需要为现有合约添加新逻辑。</font>
+ **<font style="color:rgb(31, 31, 31);">策略调整：</font>**<font style="color:rgb(31, 31, 31);"> 针对外部环境变化（如协议变更）调整核心参数或算法。</font>

**<font style="color:rgb(31, 31, 31);">2. 无代理模式下的“合约迁移”</font>**

<font style="color:rgb(31, 31, 31);">在不使用代理模式时，只能通过迁移来实现逻辑更新。其标准流程包括：</font>

+ **<font style="color:rgb(31, 31, 31);">阻断旧合约：</font>**<font style="color:rgb(31, 31, 31);"> 通过权限控制（如 </font>`<font style="color:rgb(68, 71, 70);">pause</font>`<font style="color:rgb(31, 31, 31);">）禁用旧逻辑。</font>
+ **<font style="color:rgb(31, 31, 31);">状态同步：</font>**
    - **<font style="color:rgb(31, 31, 31);">一次性迁移：</font>**<font style="color:rgb(31, 31, 31);"> 线下计算状态快照，批量在新合约中分发（如空投新币）。</font>
    - **<font style="color:rgb(31, 31, 31);">逐步迁移：</font>**<font style="color:rgb(31, 31, 31);"> 用户主动调用新合约，由新合约去老合约拉取数据或处理旧币。</font>
+ **<font style="color:rgb(31, 31, 31);">成本与沟通：</font>**<font style="color:rgb(31, 31, 31);"> 迁移涉及昂贵的 Gas 费用，且需协调所有前端、数据索引器及合作伙伴同步更新合约地址，沟通成本极高。</font>



## <font style="color:rgb(31, 31, 31);">二、 代理模式：合约升级的技术底层</font>
**<font style="color:rgb(31, 31, 31);">1. 核心原理：Proxy 与 Logic 的分离</font>**

<font style="color:rgb(31, 31, 31);">代理模式将合约分为两部分：</font>

+ **<font style="color:rgb(31, 31, 31);">Proxy（代理合约）：</font>**<font style="color:rgb(31, 31, 31);"> 负责存储所有的状态变量（如余额、所有权等），是用户交互的唯一入口。</font>
+ **<font style="color:rgb(31, 31, 31);">Implementation（逻辑合约）：</font>**<font style="color:rgb(31, 31, 31);"> 存放业务代码。代理合约通过 </font>`<font style="color:rgb(68, 71, 70);">delegatecall</font>`<font style="color:rgb(31, 31, 31);"> 指令将用户的调用转发给逻辑合约。</font>



**<font style="color:rgb(31, 31, 31);">2. 关键指令：</font>**`**<font style="color:rgb(68, 71, 70);">delegatecall</font>**`**<font style="color:rgb(31, 31, 31);"> 的奥秘</font>**

+ **<font style="color:rgb(31, 31, 31);">普通 </font>**`**<font style="color:rgb(68, 71, 70);">call</font>**`**<font style="color:rgb(31, 31, 31);">：</font>**<font style="color:rgb(31, 31, 31);"> 在被调用者的上下文中执行，修改的是被调用者的存储。</font>
+ `**<font style="color:rgb(68, 71, 70);">delegatecall</font>**`**<font style="color:rgb(31, 31, 31);">：</font>**<font style="color:rgb(31, 31, 31);"> 在调用者（代理合约）的上下文中执行。虽然运行的是逻辑合约的代码，但修改的是代理合约的存储（Storage），且 </font>`<font style="color:rgb(68, 71, 70);">msg.sender</font>`<font style="color:rgb(31, 31, 31);"> 和 </font>`<font style="color:rgb(68, 71, 70);">msg.value</font>`<font style="color:rgb(31, 31, 31);"> 保持原始用户的信息不变。</font>

```solidity
pragma solidity ^0.8.0;

contract Counter {
    uint public counter;
    address public sender;

    function count() public {
        counter += 1;
        sender = msg.sender;
    }


    fallback() external payable {
    }

}

contract CallTest {
    uint public counter;
    address public sender;

    function callCount(Counter c) public {
        c.count();
    }

    // 只是调用代码，合约环境还是当前合约。
    function lowDelegatecallCount(address addr) public {
        bytes memory methodData = abi.encodeWithSignature("count()");
        addr.delegatecall(methodData);
    }

    function lowCallCount(address addr) public {
        bytes memory methodData =abi.encodeWithSignature("count()");
        addr.call(methodData);
        // addr.call{gas:1000}(methodData);
        // addr.call{gas:1000, value: 1 ether}(methodData);
    }

}
```

[https://github.com/OpenSpace100/blockchain-tasks/blob/main/solidity_sample_code/testCall_Delegate.sol](https://github.com/OpenSpace100/blockchain-tasks/blob/main/solidity_sample_code/testCall_Delegate.sol)



**<font style="color:rgb(31, 31, 31);">3. 存储冲突（Storage Collision）—— 升级中最隐蔽的雷区</font>**

<font style="color:rgb(31, 31, 31);">文档强调了存储布局的一致性。由于 EVM 是通过“插槽槽位（Slot）”来定位变量的：</font>

+ <font style="color:rgb(31, 31, 31);">如果逻辑合约 V1 有 </font>`<font style="color:rgb(68, 71, 70);">uint a;</font>`<font style="color:rgb(31, 31, 31);">，V2 变成了 </font>`<font style="color:rgb(68, 71, 70);">uint b; uint a;</font>`<font style="color:rgb(31, 31, 31);">，则 V2 的逻辑会错误地将原本 </font>`<font style="color:rgb(68, 71, 70);">a</font>`<font style="color:rgb(31, 31, 31);"> 的数据读取到 </font>`<font style="color:rgb(68, 71, 70);">b</font>`<font style="color:rgb(31, 31, 31);"> 中。</font>
+ **<font style="color:rgb(31, 31, 31);">解决原则：</font>**<font style="color:rgb(31, 31, 31);"> 升级时只能在末尾添加新变量，禁止删除或修改已有变量的顺序及类型。</font>



## 三、实践-Counter合约升级
```solidity
pragma solidity ^0.8.0;
contract Counter {
  uint private counter;
  function add(uint256 i) public {
    counter += 1;
  }
  function get() public view returns(uint) {
    return counter;
  }
}
```

### 升级尝试 1 - 使用代理
```solidity
pragma solidity ^0.8.0;
contract CounterProxy {
  address impl;
  uint private counter;
  function add(uint256 i) public {
    bytes memory callData = abi.encodeWithSignature("add(uint256)", n);
    (bool ok,) = address(impl).delegatecall(callData);
    if(!ok) revert("Delegate call failed");
  }
  function get() public view returns(uint) {
    bytes memory callData = abi.encodeWithSignature("get()");
    (bool ok, bytes memory retVal) = address(impl).delegatecall(callData);
    if(!ok) revert("Delegate call failed");
    return abi.decode(retVal, (uint256));
  }
}
```

[https://github.com/OpenSpace100/blockchain-tasks/blob/main/solidity_sample_code/CounterProxy.sol](https://github.com/OpenSpace100/blockchain-tasks/blob/main/solidity_sample_code/CounterProxy.sol)



上面这种形式会产生如下问题

• 问题 1：代理和逻辑合约的存储布局不一致发生无法预期的错误(存储布局对齐)

• 问题 2：升级后，想添加新方法，怎么办？

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770461076337-73692540-3399-40a8-a3bb-3821e7676588.png)



• 需要解决存储布局冲突

• 实现合约地址槽位：bytes32(uint(keccak256("eip1967.proxy.implementation")) - 1)

• 升级添加的变量，必须在末尾添加

• 如何委托未来添加的函数及获取返回值？

### 升级尝试 2 - 统一委托
fallback 统一委托 解决 升级后，想添加新方法

用汇编魔法获取返回值

```solidity
assembly {
  //获得自由空闲指针
  let ptr := mload(0x40)
  //将返回值从返回缓冲去copy到指针所指位置
  returndatacopy(ptr, 0, returndatasize())
  //根据是否调用成功决定是返回数据还是直接revert整个函数
  switch success
  case 0 { revert(ptr, returndatasize()) }
  default { return(ptr, returndatasize()) }
}
```

[https://github.com/OpenSpace100/blockchain-tasks/blob/main/solidity_sample_code/CounterFallback.sol](https://github.com/OpenSpace100/blockchain-tasks/blob/main/solidity_sample_code/CounterFallback.sol)



## 升级尝试 - 通用升级
• 函数冲撞问题，若某个函数与upgradeTo() 函数选择器一样会出现什么问题？

• 透明代理（Transparent Proxy）- ERC1967Proxy

• UUPS（universal upgradeable proxy standard）- ERC-1822

• 钻石代理（Diamonds, Multi-Facet Proxy） - ERC-2535

• 信标代理（Beacon Proxy）



### 透明代理
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770465372854-e69384ad-9a5c-4722-8715-0928e57248c4.png)

TransparentProxy.sol



### UUPS
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770465392749-12e69482-a723-4431-af47-da24ce330350.png)

UUPSProxy.sol



### 钻石代理
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770465408541-2f7efbce-56d6-4bd7-ad48-f721abb84e56.png)

适合大型合约的情况

代理像一个钻石，反射到不同的实现



## 最小代理部署的合约如何升级？
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770468715451-812b575e-0361-4908-b5ea-d865678c5c20.png)

如何替换 impl ?



### 信标代理
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770468728544-79469bcf-bba5-4e5a-83b8-1cb26a0713cd.png)

最小代理工厂



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770468736705-f40cd62d-d496-4790-9d8d-74e949e166d6.png)

适合大量部署的情况



## 合约升级
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/21482780/1770468754808-392425c4-21b0-4333-ab90-8fe3b44365db.png)



### 使用 DelegateCall 要注意的点
• 代理和逻辑合约的存储布局需要一致。

• delegateCall 返回值

• (bool success, bytes memory returnData) = address.delegatecall(payload);

• Bytes 需转化为具体的类型

• 不能有函数冲撞

• 初始化问题？ - 实现合约中构造函数无效



## 实际开发中使用升级
• 通常仅需要关注实现合约

• 注意构造函数替换, 如修改为 Initializable , 避免使用合约级初始化

• 复用可升级合约：[https://docs.openzeppelin.com/contracts/5.x/upgradeable](https://docs.openzeppelin.com/contracts/5.x/upgradeable)

• 使用 contracts-upgradeable Hardhat/Foundry 插件， 自动完成代理合约部署



### 开发中使用升级（Hardhat）
• hardhat-upgrades

• npm install --save-dev @openzeppelin/hardhat-upgrades

• contracts-upgradeable

• npm install —save-dev @openzeppelin/contracts-upgradeable



[https://github.com/xilibi2003/training_camp_2/tree/main/w3_2_code](https://github.com/xilibi2003/training_camp_2/tree/main/w3_2_code)



### 开发中使用升级Foundry
• foundry-upgrades

• forge install OpenZeppelin/openzeppelin-foundry-upgrades

• openzeppelin-contracts-upgradeable

• forge install OpenZeppelin/openzeppelin-contracts-upgradeable



[https://github.com/OpenZeppelin/openzeppelin-foundry-upgrades](https://github.com/OpenZeppelin/openzeppelin-foundry-upgrades)

### 使用升级注意事项
• 用户操作的是代理，但无法阻止直接和逻辑合约交互。

• 逻辑合约状态的任何更改不会影响到代理，但是逻辑合约销毁除外。

• 如果已经使用了最小代理工厂，实现合约将无法在使用升级功能，此时可考

虑使用 Beacon 模式



## <font style="color:rgb(31, 31, 31);">三、 主流升级模式深度剖析</font>
**<font style="color:rgb(31, 31, 31);">1. 透明代理模式（Transparent Proxy Pattern）</font>**

+ **<font style="color:rgb(31, 31, 31);">机制：</font>**<font style="color:rgb(31, 31, 31);"> 在代理合约中区分“管理员”和“用户”。管理员调用则触发升级逻辑，普通用户调用则转发至逻辑合约。</font>
+ **<font style="color:rgb(31, 31, 31);">优点：</font>**<font style="color:rgb(31, 31, 31);"> 简单直观，能有效避免“函数选择器冲突（Function Selector Clash）”。</font>

**<font style="color:rgb(31, 31, 31);">2. UUPS 模式（Universal Upgradeable Proxy Standard）</font>**

+ **<font style="color:rgb(31, 31, 31);">机制：</font>**<font style="color:rgb(31, 31, 31);"> 升级逻辑不在代理合约中，而是在逻辑合约内。</font>
+ **<font style="color:rgb(31, 31, 31);">优点：</font>**<font style="color:rgb(31, 31, 31);"> 代理合约更加精简，部署成本更低。</font>
+ **<font style="color:rgb(31, 31, 31);">风险：</font>**<font style="color:rgb(31, 31, 31);"> 如果新部署的逻辑合约忘记包含升级函数，合约将永远失去升级能力。</font>

**<font style="color:rgb(31, 31, 31);">3. Beacon 模式（灯塔模式）</font>**

+ **<font style="color:rgb(31, 31, 31);">机制：</font>**<font style="color:rgb(31, 31, 31);"> 多个代理合约共用一个 Beacon 合约，Beacon 指向唯一的逻辑合约地址。</font>
+ **<font style="color:rgb(31, 31, 31);">应用场景：</font>**<font style="color:rgb(31, 31, 31);"> 适合需要批量升级大量相同逻辑合约的情况（如克隆工厂模式）。</font>

---

## <font style="color:rgb(31, 31, 31);">四、 避坑指南：不可不知的开发细节</font>
**<font style="color:rgb(31, 31, 31);">1. 禁用 </font>**`**<font style="color:rgb(68, 71, 70);">constructor</font>**`**<font style="color:rgb(31, 31, 31);">（构造函数）</font>**

+ **<font style="color:rgb(31, 31, 31);">原因：</font>**`<font style="color:rgb(68, 71, 70);">constructor</font>`<font style="color:rgb(31, 31, 31);"> 是在部署逻辑合约时执行的，它修改的是逻辑合约本身的存储空间，而非代理合约。</font>
+ **<font style="color:rgb(31, 31, 31);">对策：</font>**<font style="color:rgb(31, 31, 31);"> 使用 </font>`<font style="color:rgb(68, 71, 70);">initialize</font>`<font style="color:rgb(31, 31, 31);"> 函数代替，并配合 OpenZeppelin 的 </font>`<font style="color:rgb(68, 71, 70);">Initializable</font>`<font style="color:rgb(31, 31, 31);"> 库确保该函数只能被调用一次。</font>

**<font style="color:rgb(31, 31, 31);">2. 库合约与继承限制</font>**

+ <font style="color:rgb(31, 31, 31);">在可升级合约中，继承顺序必须保持严格的一致性。</font>
+ <font style="color:rgb(31, 31, 31);">建议使用 OpenZeppelin 提供的 </font>`<font style="color:rgb(68, 71, 70);">Upgradeable</font>`<font style="color:rgb(31, 31, 31);"> 系列版本（如 </font>`<font style="color:rgb(68, 71, 70);">ERC721Upgradeable</font>`<font style="color:rgb(31, 31, 31);">），它们已针对代理模式完成了初始化逻辑的改造。</font>

**<font style="color:rgb(31, 31, 31);">3. 逻辑合约的安全防护</font>**

+ **<font style="color:rgb(31, 31, 31);">警告：</font>**<font style="color:rgb(31, 31, 31);"> 尽管用户通过代理操作，但逻辑合约地址是公开的。</font>
+ **<font style="color:rgb(31, 31, 31);">最佳实践：</font>**<font style="color:rgb(31, 31, 31);"> 必须调用 </font>`<font style="color:rgb(68, 71, 70);">_disableInitializers()</font>`<font style="color:rgb(31, 31, 31);"> 锁定逻辑合约本身，防止攻击者通过直接调用逻辑合约的 </font>`<font style="color:rgb(68, 71, 70);">initialize</font>`<font style="color:rgb(31, 31, 31);"> 获取所有权并执行 </font>`<font style="color:rgb(68, 71, 70);">selfdestruct</font>`<font style="color:rgb(31, 31, 31);">（销毁合约），这将导致代理合约失效。</font>

---

## <font style="color:rgb(31, 31, 31);">五、 扩展思考：我对合约升级的深度理解</font>
<font style="color:rgb(31, 31, 31);">基于文档并结合工程实践，我总结出以下三层深意：</font>

1. **<font style="color:rgb(31, 31, 31);">权力的平衡：去中心化 vs. 灵活性</font>**

<font style="color:rgb(31, 31, 31);">合约升级引入了“管理权”概念。如果升级由单一多签钱包控制，这本质上是对区块链“不可篡改性”的妥协。在设计时，应引入</font>**<font style="color:rgb(31, 31, 31);">时间锁（Timelock）</font>****<font style="color:rgb(31, 31, 31);">和</font>****<font style="color:rgb(31, 31, 31);">链上治理（DAO）</font>**<font style="color:rgb(31, 31, 31);">。例如，升级提案发布后，必须等待 48 小时让用户有时间撤出资金，这才是负责任的系统架构。</font>

2. **<font style="color:rgb(31, 31, 31);">“存储插槽”的哲学与工程挑战</font>**

<font style="color:rgb(31, 31, 31);">存储冲突是很多高级开发者的梦魇。虽然文档提到了基础原则，但在复杂项目中，我建议采用 </font>**<font style="color:rgb(31, 31, 31);">Namespace Storage（命名空间存储）</font>**<font style="color:rgb(31, 31, 31);"> 模式（如 ERC-7201）。通过将状态变量存储在经过哈希计算的随机槽位而非连续槽位，可以彻底杜绝继承链变动带来的冲突风险。</font>

3. **<font style="color:rgb(31, 31, 31);">升级不是万能药，而是最后的防线</font>**

<font style="color:rgb(31, 31, 31);">过分依赖升级会导致开发时的松懈。优秀的工程实践应是：</font>

    - **<font style="color:rgb(31, 31, 31);">高覆盖率单元测试：</font>**<font style="color:rgb(31, 31, 31);"> 在本地模拟升级前后的存储布局检查。</font>
    - **<font style="color:rgb(31, 31, 31);">静态分析工具：</font>**<font style="color:rgb(31, 31, 31);"> 使用 Slither 等工具自动检测升级兼容性。</font>
    - **<font style="color:rgb(31, 31, 31);">最小化原则：</font>**<font style="color:rgb(31, 31, 31);"> 只有核心业务逻辑需要升级，周边辅助功能应尽量模块化，通过插拔（Strategy Pattern）而非整体代理来更新。</font>

**<font style="color:rgb(31, 31, 31);">总结建议：</font>**

<font style="color:rgb(31, 31, 31);">对于初学者，建议从 </font>**<font style="color:rgb(31, 31, 31);">OpenZeppelin Foundry Upgrades</font>**<font style="color:rgb(31, 31, 31);"> 插件入手，它提供的 </font>`<font style="color:rgb(68, 71, 70);">upgrades.deployProxy</font>`<font style="color:rgb(31, 31, 31);"> 等方法能自动处理初始化检查和存储冲突验证。而在面对大规模并发合约部署时，</font>**<font style="color:rgb(31, 31, 31);">Beacon 模式</font>**<font style="color:rgb(31, 31, 31);">则是平衡 Gas 成本与运维效率的最优解。</font>





## 练习题
### 练习1
• 编写一个可升级的 ERC721 合约

• 编写一个可升级的 NFT 市场合约

• 第一版本普通合约

• 第二版本，加入离线签名上架 NFT 功能方法（签名内容：tokenId， 价格），实现用户一次性 setApproveAll 给 NFT

市场合约，每次上架时使用签名上架。

• 部署到测试网，并开源到区块链浏览器（在 Readme.md 中备注代理合约及两个实现的合约地址）

[https://decert.me/quests/ddbdd3c4-a633-49d7-adf9-34a6292ce3a8](https://decert.me/quests/ddbdd3c4-a633-49d7-adf9-34a6292ce3a8)



### 练习2
• 理解合约升级涉及的存储布局

• 编写可升级合约时，如果第一个版本逻辑实现合约中有一个 mapping（ uint -> User） users ; User 是一个结

构体类型，请问在第二个版本的逻辑实现合约，可否在User 结构体里添加一个变量？ 请说出你的理解。

• 编写可升级合约时，如果第一个版本逻辑实现合约中有一个数组 User[] users ; User 是一个结构体类型，请

问在第二个版本的逻辑实现合约，可否在User 结构体里添加一个变量？ 请说出你的理解。

• 编写可升级合约时，如果逻辑实现合约有继承关系，什么情况下能父合约里添加变量？ 你认为的最佳实

践是什么？

[https://decert.me/quests/8ea21ac0-fc65-414a-8afd-9507c0fa2d90](https://decert.me/quests/8ea21ac0-fc65-414a-8afd-9507c0fa2d90)



### 练习题3
• 在以太坊上用 ERC20 模拟铭文铸造，创建可升级的工厂合约：

• 方法1：deployInscription(string symbol, uint totalSupply, uint perMint)

• 方法 2：mintInscription(address tokenAddr)

• 第 2 个版本加入铸造费用（price）

[https://decert.me/quests/ac607bb0-53b5-421f-a9df-f3db4a1495f2](https://decert.me/quests/ac607bb0-53b5-421f-a9df-f3db4a1495f2)



































